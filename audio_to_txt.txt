整理成为我们想要的一个干净的 我们称之为一个干净的数据格式对吧 那么干净的数据格式大家想一想 在我们SPSS里面我们是不是有固定的这个数据格式的 大家如果还记得SPSS内容的话 假如说我们是问卷的内容对吧 那么我们希望得到的是一个什么样的一个格式 每一行是一个base的数据对吧 假如说有问卷的话最好是每一个链 代表的就是一个问卷的一个item 甚至最好的是它就是一个问卷的得分对吧 这样的话我们就得到了每一行代表一个base 每一链就代表一个问卷得分或者是一个只问卷得分 那么我们接下来就可以做剩下的分析了对吧 比方说我们想做回归对吧 我们想做中介的分析等等 当然甚至我们如果是每一链对吧 它是一个item的数据的时候 我们实际上还是可以对它利用SPSS的一些功能 对它进行求核诸如此类的对吧 这也是我们能够在SPSS里面做的 或者在JASP或者JAMuvi里面做 那么我们今天讲的内容就是说如何将我们从 就是直接从那个比方说问卷 问卷机器上面download下来的 或者是从我们实验的软件里面生成这些数据对吧 把它进行一定的预处理 那么得到我们最后想要分析的数据 今天就是我们这节课要解决内容 那么这节课内容实际上我们只是做一个示范 那么也就是说当大家真正的去预处理自己的数据的时候 这一部分实际上是很头疼的 要自己去花点时间去把这个逻辑想清楚 那么我们之前先解决一个 上节课大家其实问的比较多的问题 其实也是我们这节课准备讲的一个问题就是 当我们有多个数据的时候对吧 我们想一下把所有的数据都读进去 然后把它合并起来对吧 合并起来之后的话 这样就能够得到一个完整的数据 尤其像我们这个Base的这种 像认知实验对吧 那么每一个Base它是一个单独的文件夹 那么如果我们一个一个读 然后把它合并起来的话容易出错 而且的话效率非常低 那么我们现在有两种方式 一个是for loop 那么for loop它的一个好处就是 它的思维的难度比较低 它的这个怎么说呢 比较符合这种直觉的方式 就像是我们把它读进来 然后一个一个的再把它进行读取 然后合并 它的这个就是怎么说呢 如果我们去读这个代码的话 我们发现for loop是比较好理解的 因为它把读取数据以及合并的各个环节 都分解开来了 比较清晰 然后在现在R里面也集成了一些代码 能够帮助我们去叫做 直接去对一些list进行操作 相当于我们不用一个一个去做 而是一下就把它 把我们的一个函数应用到 某一个list里面的每一个元素 然后它就自动帮我们做了一个 类似于for loop的一个工作 那我们看一下怎么去读 那么在去使用for loop之前 我们还要有一个了解一个知识 就通透服 也就是说大家想一想 我们现在需要从电脑里面读取一堆文件 对吧 那么读取文件的时候 我们大概是有两个步骤 大家想想我们第一 上上节课学到内容对吧 我们学的就是相对路径和绝对路径 为什么要学这个东西 因为当计算机或者是R元 要和我们本地的文件夹交互的时候 它必须要去进一个读取本地文件夹 对吧 假如说我们这里是一个本地文件夹的 一个文件夹对吧 大家这是一个文件夹或者硬盘的一个空间 那么大家可以想 把R到这个处理器对吧 一个processor 现在已经不考三词默写了 反正我都默不对 那么首先假如说我们要知道 我们要去读取 比方说这里面有一系列的文件对吧 比方说F1 F2 这是8A1 8A2 8A3对吧 那么我们要去读它的话 我们要去找到它的路径对吧 或者说我们是要把它路径输入进来对吧 那么这样的话我们就需要找到这个文件 它的director对吧 它这个路径的问题 然后我们同样也要知道它的路径对吧 每一个路径 然后把这个路径输到 就是把它作为一个字符串 输到一个命令对吧 输到这个process里面 它才能够去读取对不对 这是我们上节课讲 我们去阅读CSV的时候 我们会给一个完整的路径对吧 实际上就做了这个事情 理解吗 我们上节课讲读取CSV的时候对吧 我们会给一个.out文件 我们会把它的完整的 我们会给一个相对的路径对不对 这个还记得吧 为什么我们要给一个相对的路径 我们就是让R运算的计算机对吧 我们相信让R里面内部的一个engine 一个计算机对吧 它知道这个文件在哪 然后并且对这个文件实施一个功能 就是readCSV对不对 我们现在要读一串对吧 读一串的话我们需要怎么办 我们肯定就是要把这一串文件的 相对的路径都读进来 然后依次把它给这个processor对吧 然后它读取了之后 然后它这里可能有一个小的空间对吧 它可以把它存在这里 然后说这边是通的对吧 它可以把它暂存在这里 然后一块一块的 然后再把它合并成为一个完整的对吧 这个东西的话可能我们不知道 我们也看不到 但它最后就输出一个结果 然后就是一个完整的 一个data frame对吧 然后我们说data frame work对吧 所以我们现在要用 不管是我们要用for loop还是用apply对吧 我们都要做这个事情 就是把所有文件的这些路径 都把它列出来 然后把它输入到这个processor里面 然后让这个processor对它做一个运算 就是readCSV这个运算 每一个文件readCSV之后 它都会生成一个数据框对吧 然后再把它进行合并 成为一个完整的数据框 这是我们要做的事情对不对 那么我们的输入是什么 我们输入就是一个个的文件夹对吧 的文件名对不对 那么我们现在大家可以看一下 自己的电脑的文件夹的点号子文件 那么大家会发现我们有很多对吧 有practice 然后有match 还有category 除了前面的一大串的 表示base的信息以外的这些信息以外 它还有这种practice和match 还有category对吧 它表示的是三个时间的三个阶段 practice表示它在做练习 然后match表示它在做match的任务 然后category表示 它在做categorization的一个任务 那么我们现在要做的是什么 我们在课堂上我们只会演示一个 就是我们需要把所有这个文件名 这个文件名里面对吧 比方说我们说fe我们把它单独拧出来看对吧 它可能就是 data 然后match 然后我去一个好像就是比方说 它就是什么点out对吧 那么这中间有一个字符的表示 它的实验任务就是match对吧 这个大家都能在自己电脑上看到吧 那么我们现在要做的是个什么事情 就是把所有包含了match 然后以out结尾的这些文件都找出来对吧 因为这个才是我们需要去读取的 这里的f1 f2 f3是吧 一直到所有的base 这个逻辑大家懂吧 所以这个时候我们需要 我们肯定不想把每一个文件名都把它 精确的列出来之后然后做输入 因为这样太长了 大家明显可以看得到对吧 这是一个很低效很容易出错 而且是一个很笨拙的办法 那么我们这里就会用到一个函数 就是用r里面去 把文件夹里面的一个函数列出来 就像是说我先对这个文件夹 做一个命令 假如说我可以给它做一个命令对吧 就是我list它所有的文件这里面 所有的文件我都把它列出来 这个是r很容易做的一件事情 就它把这个文件夹扫描一遍 里面有多少个文件夹 有多少个文件全部给你列出来 不管你有没有隐藏 这是很容易做的 但是这是不是我们要的东西呢 它把整个文件夹扫描一遍 把所有的里面东西都列出来 我们是不是直接就能够把这个 列出来的东西做输入 然后读取 然后就把它合并成我们要的东西 很明显不是对吧 因为它包含了其他的内容 这个时候我们就要有选择 我们如何去选择它只包含一部分 就是制服它的文件名里面 包含了match的文件的名字 这个时候我们就需要用到一个通配服 这就是大家在电脑上看到的 它是一种叫它是在很多不仅是R里面 在很多计算机语言里面都存在的一个特殊的制服 就是说它可以做一种 我们可以认为它就是一个 一个general的一个制服代表的是什么呢 就这个地方你无论是什么制服都可以 我都把你拉起来 这样的话我就能够进行一个匹配了对吧 比方说像这里 我们最常用的一个通配服应该是第一个 就是这个信号它代表就是任意的制服 如果说我们信号.csv的话就表示 你所有满足以csv结尾的这样的文件 我们都把它读取出来 也就是说它会在这个文件夹里面扫描一遍 然后你所有以csv结尾的 我都给你读取下来 然后成为一个list 然后这个list就是一系列的文件名 假如说我们是真的以信号.csv 去读我们这个文件的话 大家想想那我们得到的是一个什么东西 回答这个问题 能够回答这个问题 表明大家说你能够感受到这个东西 假如说我们真的是以.csv去匹配对吧 去用这个list的这个函数 去扫描一个文件夹 那么它意味着什么 我们要找到这个文件夹里面所有 以.csv结尾的文件对吧 如果我们看这个match这个文件夹里面的话 data match这个文件夹里面的话 这样的话我们能够找多少个文件 能找到是吗 以csv结尾的文件我们能找到几个 0个 对吧如果说大家用的是我们原来一开始 发给大家的数据的话 应该找到的是0个对吧 理解吗 确定理解吗 我再把这个逻辑说一遍 因为我看了有些同学还没有点头 就像跟叔叔说我们现在 要再假如这个正方形代表的是我们现在 当前存储这个数据的一个文件夹对吧 里面有一系列的文件 那么我要去把这个里面的一部分的文件 进行读取对吧 输入到这个R里面进行读取 用CSS这个函数对它进行读取 那么我们要做的第一个事情就是 或者说我们能够使用的一个命令 就是去扫描这个文件夹 不一定是ls就是去扫描这个文件夹对吧 把这个文件夹里面所有的文件 包括文件夹都读取出来 那么这个时候的话我们能做这个事情 但它不能不完全符合我们的目标对吧 因为我们要的是只有max这个条件 就是说max这个条件的数据 然后点out结尾的这样一个数据对吧 所以我们列出max这个文件夹里面 所有的文件的话 它是不符合我们的目标的 这个时候我们就需要一个 通配符对吧 去匹配文件夹里面包含了特殊信息的一些文件。 也就是说我们要对文件夹里面的文件, 根据他们的文件名是否包含match进行筛选。 那么这个时候我们就要用到这个通配符, 尤其是这个信号这个通配符,为什么呢? 因为它在计算机语言里面代表的就是任意数量的任意数字。 也就是说当我们以信号.csv结尾的时候, 代表的就是这个文件夹里面我们扫描的时候, 只要它是以csv结尾的, 我们就全部把它读出来,把它文件名完整的读出来。 如果它不是以.csv结尾的, 那我们就把它给跳过。 那么问号它是代表单个字符, 也就是说信号代表的是任意的任意字符,对吧? 信号代表的是任意的单个字符。 这里有个例子就是说,如果我用file,对吧? 然后问号.txt,那么它能够匹配的符合条件就是 file1,file2,file3,等等等等。 但是如果你是file10,对吧? 它后面有两个字符,这个时候它就不匹配了。 那么这个中括号两个就表示它是一组字符。 那么这个字符就是里面是用或的关系。 就是这个中括号里面的,比方123就是 file1,后面跟1也可以,跟2也可以,跟3也可以。 就这样可以任意的去,比较灵活的去匹配。 因为有可能你知道,比方说它就是 file后面12345678910,对吧? 然后你也不知道具体这个文件夹里面有几个, 你就把它全部写在里面,它只要包含在里面了, 我们就把它读取出来。 那我们怎么用它呢? 这个首先看一下我们的路径,就是 每个人路径是不一样的,我们先 当前的路径的话,这是我们助教的这个 电脑上的路径,然后在我电脑上的路径可能不一样, 我还没有去把它render出来。 然后我们会用tidyverse这个包, 我们后面整个把它load之后的话, 后面就不用再去管它了。 因为我们之前,为什么要加这个东西啊? 我之前好像记得我们讲课的时候, 每次没有专门讲,就是说我们开始处理之前 要load这个包,后面下面转的时候就犯错了, 就是说我就直接开始用这个函数, 但是实际上还没有加了这个包。 这是一个准备工作,提醒一下大家。 然后找到了我们现在的这个工作路径,对吧? 然后我们可以用两种, 这个for loop,对吧? 比方说我们这里的pattern, 我们用的是,比方说首先是前面是它的一个路径,对吧? 这个我,首先我们一部分一部分讲啊。 files,一个变量名, 我们要用这个变量名来装我们所有从这个 围绕架里面扫来的文件的名字。 这个是我们比方说这里采用的一个名字,对吧? 我们也可以采用其他的名字,比方说filenames等等等等, 或者是filename, 但是就是你一定要,如果是命名的话, 我推荐就是说这种情况一般用复数, 你就知道它实际上是一个包含了多个值的一个变量。 然后这个list files就是R里面的一个函数, 那么这个函数呢,前面的是你的这个文件夹, 我们刚刚说了对吧? 你要在这个文件夹里面扫描, 那么我们用什么扫描呢? 就用list files这个函数进行扫描。 那么第一个argument,第一个函数就是你要在哪个文件夹里面扫描。 这个时候我们的这个filepattern就是一个相对路径对吧? 我们在当前的工作目录里面的data, 然后这个指纹夹里面的match的指纹夹给你扫描。 然后扫描的时候,这个pattern是什么? 假如你不填这个pattern的话, 它会把里面的所有东西都扫描出来。 然后我们用这个pattern就是说, 我们要对这个文件夹里面的这个文件名如何进行筛选对吧? 我们要筛选这个,比方说包含了这个match的对吧? 或者是像我们这里更加精确对吧? 我们要以这个match,就是data experiment 7对吧? 然后repeat,然后match这个开头的。 然后呢,这个后面是一个通配符对吧? 然后表示就是说所有以这个out结尾的, 我们都把它扫描进来。 然后这样的话,扫描完了之后,我们就得到了 所有的符合我们这个模式的这些文件的名字。 那么我们并且只会得到他们的文件名,不包含他们的路径。 但是我们把它这个读取之后的列出来的话, 列出来前面10个的话,我们就可以看到, 它确实就是我们完全符合我们上面那个规则对吧? 那个模式,就是以这个data什么什么开头对吧? 然后这个地方就是通配符刚刚,刚才所代替的对吧? 所以现在是我们以前面这个作为筛选的一个标准, 然后后面的这个地方,你就任意的是什么东西都可以, 然后以点out结尾对吧? 实际上我们这个pattern代表的就是这么一个东西。 那么这个nist files,它实际上就是说扫描这个文件夹, 并且按照你给的这个特定的模式去扫描文件, 这个在我们的任何一个计算机里面都是非常非常重要的, 为什么?因为它就直接涉及到我们的这个软件如何和我们 文件夹里面的数据进行交互对吧? 那么在R里面的话,我们就经常会用这个软件去读取数据, 当然其实也就是第一步,读取完之后,后面我们再不需要它了。 但是这个东西的话,对于初学者来说还是需要了解为什么要这么做。 那我们现在就是读取到了就是一系列的相当于一个vector对吧? 然后这个vector里面,一个项量里面包含了很多这个字符, 每一串字符代表的就是一个文件的名字。 这个大家有没有问题? 因为我们这个跟我们前面讲的有点不一样啊, 就是我们前面讲读取文件对吧?我们是读取单个文件, 那么现在我们做的这个操作是把一个文件夹里面的所有的 所有符合某一特定模式或者符合某一规则的这个所有的文件的名字都列出来。 然后我们读取完了之后,如果我们用for loop的话就是 我们可以用,首先是,然后我们先把这个讲完。 首先我们要创建一个空的list,然后用来存我们装, 就是说我们读取的这个数据,然后呢,这个for loop就表示就是for开头, 然后一个中括号表示这个for的这个范围,循环的这个范围, 然后呢,有一大括号,它必须要有另外一个大括号结尾, 要不然的话它就会出错,也就是说我们整个for loop的一个结构是。 for,然后中间一个条件,然后这么一个括号, 然后下面一般也要有一个反括号,中间就是你要填的内容。 这里大家应该能够看到这里是反的括号,对吧? 那么我们for的话,我们说是循环,对吧? 它意思是什么?就是说我根据你的,我用i对吧? 然后in,比方说一个sequence,这个sequence就代表的是什么? 比方说我们说,sequence1到10,对吧? 它就表示1,2,3,4,一直到10。 那么这个in,这个表示什么呢?就是说我们i的范围就是从这里, 就从这里,从1到10。 那么我们后面在这个for loop里面肯定会用到i,为什么呢? 因为它表示我们逐个的去循环,对吧? 然后我首先i等于1的时候,我做某一件事情,对吧? 完了,就到了这个for loop的结尾。 然后在i等于2的时候,我又同样的对上这里,对吧? 一直到i等于10,完了,这个for loop就结束了。 这是for loop的一个结构,对吧? 那么我们现在看我们在这个for loop里面要干什么? 我们第一个就是df等于readtable,对吧? 就是说我们用把readtable的这个函数去read一个文件。 那么这个文件的path,就是它的路径的话, 实际上就是一个相对的路径,对吧? 是前面的这个data match,然后再加上后面这个files,对吧? 这个filesi的话,大家还记得的话,它实际上是我们里面的一个文件的名字,对吧? 所以如果说i等于1的话,它实际上就是什么呢? 这个时候我们读的是什么?就是第一个文件,对吧? 第一个文件我们把它读取进来了。 然后我们按照这个header的true这种方式去读,对吧? 那这个时候我们把它做一个转换,就是我们在这个for loop里面, 我们内部先把它进行一个转换,就是为了避免后面出错。 因为这是我们试出来,就发现out文件里面保存的可能会不是那么的统一。 那么我们将这个,比方说data不等于data, 就是说我们读取这个某一个out文件之后呢, 我们之前说过,对吧?它可能中间又重新出现了,比方说date, 然后subject,id,等等等等。 它把这个column name又重复了一遍,对吧? 我们要把这样的role给去掉,对吧? 那么我们用什么规则呢?就是说我们可以用一个规则就是 这个date这个column,对吧?它其实上面有一个date, 就是表示做实验的日期,它下面应该是日期,对吧? 一个一个的日期,对吧?但是如果它再次出现这个data这个数据的时候, 表示什么?表示它重复了上面这个column name,对吧? 所以的话,我们可以把所有的这样的行的话就去掉,对吧? 所以我们用了上次课选择的那个,就是筛选的那个函数,对吧? 我们就把这个地方反向的筛选掉,然后反向筛选掉之后, 我们还可以对它这个数据的这个变量类型做一点点这个变化。 这里面全部是,比方说大家上几个我们有可能提到的, 就是比方说我们要让一个变量,对吧? 它是字符的话,我们就用as correct, 然后如果说它是这个,我们看有没有as numerical,这里。 我们要它是数字型的话,就要让它变成as numerical,对吧? 我们基本上就是用了这两种,就是把所有的这个column 都变成我们想要的类型,然后的话,这里就生成了一个df,对吧? 并且进行了转换,它实际上是什么?当我们i等于1的时候, 它就是对第一个文件做了这一番操作,对吧? 然后呢,我们就把它复制到这个data list里面, 就是我们上一课创建的一个空的list, 那么我就把它作为这个list里面, 这个空的list里面的第一个位置,把它插入。 我们这两个就是list里面,它是非常灵活的, 它可以装vector,可以装data frame,可以装matrix, 它还可以装array,它可以装很多东西。 那么我们这个list里面就装data frame,对吧? 我们这个list里面第一个位置,就是最后就变成什么? 我们做的第一个out文件,它经过了转换之后的df, 就装到这个df list里面,第一个,对吧? 那么同理的话,我们第一个读完了之后, 我们就去这个id位循环,就读第二个, 然后一直倒计10个,读完。 那么假如说这个files里面,它有10个文件加名字的话, 我们最后就,这个data list的长度就是10,对吧? 它里面就有10个我们读取的数据。 那么我们假如说把所有的数据都装到这个list里面以后呢, 我们就可以把它怎么样,把它合并成为一个大的数据框。 我们就用这个bind rows, 这是DPRY里面一个很常用的一个function, 就是我们通过行来把不同的data frame进行合并。 那么这样的话,我们刚刚说了,这个data list里面, 它实际上是我们读取了一个一个的out文件之后, 并且经过了初步的转换之后,形成了一个完整的list,对吧? 那么现在把所有的list data frame按照行进行合并, 就像是把它,把它的每一个,因为它们的column都是一模一样的,对吧? 我们就直接把它往后面去,去叠加,那么最后的话我们就得到一个完整的 DataFrame 这就是 for loop 的一个逻辑,就是我们先读取 我们想要的文件的名字,然后我们通过这种迭代的方式 是吧,一个一个的去读,读取之后把它装到一个 DataMist里面,就是我们自己创建一个Mist里面 然后再对这个Mist进行一个完整的合并 那么这个思路大家想想是非常 straightforward 对吧 大家都能够想,我们就是要去读的话 就是一个一个读,然后合并对吧 很符合我们的这个常识 当然符合常识的一个前提是说我们要理解 这个 for loop 到底是怎么样的 那么为什么我们,我每次讲 for loop 的时候 其实助教其实,这个有点快 助教们可能有时候觉得没有必要 因为可能 for loop 它使用的其实非常少 但是我个人还是觉得要讲这个 for loop 为什么呢 其实 for loop 它不仅是说我们可以用在这里 而是我们可以用在很多个场景之下 就当你要重复做某一件事情的时候 没有现成的函数帮你做某一个事情的时候 对于你要说最简单一个办法,你就是写一个 for loop 然后它进行循环,迭代的帮你做某一个事情 然后那个可以替代的 就是 i 就是说你用 i 来,就是 比方说你有五个东西,对吧,你要做同样操作 你就可以把它写一个 i 1到5 的一个 for loop 对吧,把每一个放进去做同样操作 这样的话你就不用再去一个一个去复制你的代码 然后说你的代码有,你要做那个操作有20行对吧 然后你把那个代码复制一下 然后改其中的一个值,然后再跑一遍 我不知道大家写的这个R代码是有没有这样 我刚开始是经常这样改 但是你后面学会了for loop之后 就是经常进行偏向处理的话,这个效果就好多了 那么对于我们,因为我们这个就阅读文件对吧 从文件夹里面阅读文件,然后把它合并 是一个经常经常经常要做的事情 所以太常用了之后呢 以至于大家就直接开发一个更简洁的一个功能了对吧 这是for loop的结果,那就是LPi 那这里呢我们用了一个开始就直接用管道了 我跟大家讲一下 这个地方我们实际上是用了一个比较 就是说比较复杂的一个做法 我们把所有的操作都就是连到一起 然后呢直接得到最后的结果 首先我们介绍一下这个符号 我们之前可能还没有介绍过 就是这个符号 两个百分号中间一个大余号对吧 那么这个符号表示就是 在DPLYR这个包里面的一个管道操作 这个管道操作就是说我们把前一步的结果 它输出的这个结果,不管这个结果是什么 一般来说可能是data frame是最好的 然后直接把它输入作为下一个函数的输出 所以比方说我们在这里看到 就是它这里有很多这样的符号对吧 每一个符号代表就是我们做了一个操作 每一个步骤都是一个操作 那么我们这里的第一个操作 这个是我们最后的结果对吧 我们是用LPLI的这个表示 区分我们之前for loop的那个结果 那么第一个这个是我们刚才讲过的对吧 大家看到我们刚才就是说用这个符号 来把所有的这个文件夹里面所有的符合我们条件的 这个文件的名字都列出来对吧 这个时候我们得到了一个什么 得到一个list对吧 然后把这个list作为一个输入 输入到什么呢 就是一个叫LPLI的一个函数 那么LPLI它就是 大家可以看到这里是 首先第一个是function x对吧 就是我们要把这个function x 要应用到什么东西上去 那么这个function x代表什么 就是read table 就是说我们要把read table 这个这个函数应用到 接下来一个list里面的每一个元素上面去 那么这个list是什么 就是后面这个对吧 就是file path 这个后面这个x 然后它有一个argument 就是说这个argument实际上是read table的一个argument 就是head等于true 这个实际上是什么呢 就是说它用一行命令 做了我们刚才用for loop做的事情 就是我们把read table 然后file path这个应用到每一个x 那么就是这个叫做 这个LPLI应该是apply系列的一个函数 应该是list 就是我们把这个函数应用到一个list上去 那么它还有其他的一系列的apply的功能 都是去简化我们这个for loop的一个操作 也就是说你可以用for loop 你也可以用LPLI 看有个同学已经快要睡着了 讲这种知识的时候确实是比较枯燥 但大家一会儿练习的时候估计就要醒了 因为可能会出错 然后我们把这个大家想想 我们把这个read table对吧 应用到每一个x之后 那我们就得到了什么一系列的 也是另外一个意思对吧 这个意思是什么 就是一系列的data frame对吧 每一个data frame就对应着我们的一个out文件 然后我们再同样的对这个 就是每一个data frame再做一个操作 那么这个其实是一个很复杂的操作 就是把这个大家看到前面是apply的function对吧 然后那相当于是一个function的一个marker 就是代表它是在做这个function 那么这个function内容是什么呢 它其实就是非常复杂的这个东西 一系列这个东西一直到这儿 然后这个LPLI的结尾是在这儿 所以大家可以看到我们当我们用LPLI的时候 其实我们可以在这个中间插入很复杂的一些东西对吧 它只要是一个能够就是一个比较完整的函数就可以了 而且这个函数跟我们的输入输出都是匹配上的 然后这个地方我们是用df对吧 就是用data frame来做一个 这个地方比方说是data frame 那这个地方我们filter对吧 我们就是说我们对把这个函数应用到什么上面 上面我们是x对吧 所以我们这里应用到x上面去 这里是df我们应用到df上面去 我们对这个list里面每一个df都进行同样的操作 这个操作实际上就是我们在for loop里面做的操作对吧 就是对它的每一个column进行一个转换 那么完了之后的话它就会得到一个list 这个list的data frame全部进行了一系列的转换和操作对吧 它能够进行了这个合并 然后我们就用这个bind rows 那么这个地方它就默认的就是我们直接把上面的这个 输出的结果就是一个data frame list 然后就直接作为这个bind rows的一个输入 所以在这个地方我们的这个括号里面没有argument 就是因为在管道操作的时候 我们直接是默认的把上一步的输出做下一步的输入 那么有的时候我们也可以比方说 这个下面这个函数它有多个 它有多个这个argument对吧 它有多个需要输入的参数 我们用点来代表上一个上一步的输出 我们后面可能会看到 所以大家可以看到就是说虽然说L2i对吧 我们说它是一个很压缩的很营锁的一个情况 但是它就真的就是跟压缩饼干一样 它是不好消化的 就它的这个如果你要去很熟练的使用它的话 你必须要知道里面的这些细节 有可能你还要经过试错 那么像我们再回过头来看这个for loop 这个for loop看起来就是比较冗长一点对吧 代码冗长一点 但它的这个思路是比较简单的 它的思路就是很清晰的对吧 我做什么一步一步的做什么 那么我们用L2i和这个for loop合并的 我们最后都得到是同样的数据 就是有16个变量 然后有25000多个observations 就是25000多行 OK那么我们假如说我们已经把这个数据读出来之后 对吧 那么我们还有一个很重要的功能 就是我们一般会把自己的中间结果保存下来 因为我们不希望每次打开R以后 我们重新把这个过程再做一遍对吧 当然可能重新做一遍也无所谓了 因为你的数据基本上不会变 但是你可能就要每次都运行上面的这段代码 但是你可以就直接用writecsv对吧 把刚才读取的这个然后把它保存下来 那么writecsv的话它的这个也很简单 就是把这个csv写下来对吧 我们前面的话就是刚才那个 整理完了之后合并完了之后的那个数据框 然后我们给它一个名字对吧 比方说这个名字就是在 这个地方这个名字啊 大家可以看到我们不仅仅是要给一个名字 而且还要给它的一个路径 也就是说这个地方我们用 用的是一个相对路径对吧 还是在当前的工作目录下面这个data 然后这个match下面 把它存储为一个叫做 match-row的一个csv对吧 然后一个很常用的一个argument 一个参数就是row names等于force 就是说我们不要让它的这个 row name写出来 要不然的话它会把这个row name就是 123456789是一直到25000多 就写成一个单独的一个column 这个对我们来说没有任何意义对吧 所以我们一般就会把这个让它等于force ok那就是我们去读取多个文件的时候 应该怎么做 那后面的话大家可能会经常会 要是有单个的数据的话 会经常要用到这个命令 当然大家应该也是能够找得到 但是我们就给大家讲解一下 ok那我们假如我们已经把这个数据准备好了 对吧能够去读取了 然后比方说我们 这个match的数据也读取也准备成一个csv了对吧 然后penguin的data也可以准备成为csv了 那我们就读取数据 然后就开始我们今天的这个数据预处理了 大家看到这里我们就读取刚才保存那个csv对吧 那么我们就用的是这个比方说head等于true 然后separator这个sep等于这个逗号对吧 因为我们自己保存csv的时候 实际上就是用逗号分割的 那么我们的这个数据处理的基本操作 应该说准确说应该是叫做在tidyverse里面的基本操作 那么tidyverse的话它实际上是一个目前来说 我觉得是目前被社会科学家或者是心理学家 最有推荐的一个数据预处理的包之一 它里面包含了非常常用的一些功能 那么它能够解决我们数据预处理 绝大部分的一些问题 那么filter我们其实之前已经讲过了对吧 那么这是它常用的功能之一 然后另外就是mutate就是生成一个新的功能 然后groupby就依据某一些变量产生这个条件 然后对数据进行分组 那么如果我们使用groupby的话 一定要记得使用这个ungroup 就是说我们把它把这个分组的这个mark去掉 然后用summarize进行一些计数 然后求均值求SD求SE等等 那么我们把groupby和summarize加到一起的话 我们就可以非常有效的快速的去得到 我们心理学中常用的一些统计量 比方说你要求均值要求SD求SE对吧 求那个计分数等等等等 都可以分组进行分条件进行 那么我们刚刚说的ungroup对吧 在你summarize完了之后已经ungroup 然后这个select就是你选择 我们刚刚的filter对吧 这两个是不一样的 filter是选择符合某一个条件的行 就是对行进行选择 select是对column对列进行选择 那么有的时候的话我们也可以 通过select这个函数进行重新的排序 然后arrange也是我们非常常用的一个函数 它实际上就是在类似于excel里面的一个排序 我们依据某一个column的值 对整个data frame进行排序 排序完了之后的话 有的时候我们可以看到一个比较简单的清晰的模式对吧,OK,这是我们常用的一些功能,我们接下来看一下 比方说我们首先就是做一个简单的一个 就是挑选行对吧,比方说我们认为95年 我们要找到95年龄大于就是95年或者以后出生的人对吧 那么这个时候的话我们直接把它放在这个管道里面对吧 那么管道操作是这样的,管道操作我们有两种 有的地方我们可以直接以我们的输入作为操作 就是从这个地方开始,我在这里选中这个df 从这个地方开始,然后直接用管道符号对吧 然后用这个dplyr然后filter 这个地方大家看到有个点对吧 这个点就代表的是我们输入 也就是我们上面这个,它其实没有做任何的操作对吧 它就直接做一个输入到下一个 相当于是大家可以想象那个管道就是我们流水线对吧 它这个东西就直接流到下一步了 下一步做什么呢,就是filter对吧 这个点代表的就是我们把这个上一步流进来的这个数据放在哪 放在我们这个下一个函数的哪一个做哪一个argument 因为这个argument它实际上是有顺序的 我们一般比方说在这个很多dplyr里面这些 这些函数里面,第一个都是要一个data frame 就是一个数据框 所以我们很多时候直接把点放在这里 然后我们用age对吧,年龄作为筛选 大于95年的,这是我们做的一个筛选对吧 那实际上假如说我们,我们筛选完了之后呢 现在是我们看这个东西,我们是先是做后面的 从这个地方,从这个地方就是row开始 这个不太好选啊 从这个地方开始选择完了之后呢 把选择完的结果最终输入到,大家看到这个地方是负值对吧 把里面的负值符号,然后再重新输入 输入到dataclean filter里面 也就是说我们是先从某一个变量开始 把它作为管道的起始点 然后做一系列操作 最后呢我们再把它复制到前面的这个变量名上面去 选择 那么我们不复制到前面可不可以呢 也可以,它就直接给它打出来了 但是这个时候你就不会生成任何的变量 如果你要保留这个变量的话,你必须要给它复制 那么我们选择变量,就是这个时候选择的是 选择是什么,是这个column对吧 比方说我们可以选择与这个Alex这个 应该是一个与这个肃清障碍相关的一个问卷对吧 那么我们就可以直接选择这个 这个startwith startwith实际上也是tidyverse里面的一个包 就是说它会选择在这个 在这个 data frame里面所有的column names里面 以Alex开头的所有的column 它本质上就是一个通配符 大家还记得我们刚才讲通配符对吧 它本身是一个简化通配符 为什么呢,因为在DPIY里面 我们经常要做很多操作 就是我们要选择以什么开头的一些column names 或者以什么结尾的一些column names 或者怎么样的对吧 那么如果我每次都在这里面写通配符的话就很麻烦了 那么它直接就把这个东西打包在里面 就是你直接用这个startwith 然后一个字符Alex,就表示说 那么我们就在这个数据库 在这个data frame里面选择所有以Alex开头的这些column 那么它得到的是什么,得到的是一串字符对吧 那么这串字符的话就是我们要选择的 那么我们也可以把它和其他的选择一起放在一起 比方说我们第一行就是age对吧,年龄 然后这个eat drink表示它是不是有吃或者喝东西 然后avoidance 那么这样的话我们选择之后 我们就可以能够看到这个 大家可以看到就是age 然后Alex1,1,2,3,4,5,6对吧,所有 那么一个比较笨的办法 当然就是你把所有Alex都写出来 Alex开头都选出来对吧 这样的话就比较就比较费时间了 所以这里面也用到了我们这个 通配符的这么一个功能 然后我们可以一般来说我们可以比方说 生成一个新的变量 这个mutate的话它其实有很多功能 不仅仅是说求和 我们甚至可以 它的这个mutate就是什么呢 就是基于现在data frame里面已经有的一些 数据做一些转换 这个转换可以是任意的 可以加减乘除或者可以判断是否 whatever对吧 你把它转换之后生成一个新的变量 所以它叫mutate mutate就是变的意思对吧 就是你要变出出现在的data frame的columns里面 你变出一个新的columns出来 那么我们这里就是做一个很简单的一个做法 就是mutate的就是说 我们把前面的Alex4个 这个items的得分对吧 把它求和 那么我们会得到一个Alex3的这么一个变量 那么这个变量的表示就是什么呢 表示就是这前面四个Alex1Alex2 Alex3 4的他们的得分的和 那么它是实际上是逐行求和 这个时候大家一定要注意就是说 它实际上就是以 就是相当于是把 这四个 这四个相加然后得到这个Alex3的第一个数值 然后这四个相加得到第二个数 这四个相加得到第三个数 然后一直内推 所以它实际上是这种逐行运算 那么所以我们也可以因为它是逐行运算对吧 所以我们实际上就可以用其他的函数 比方说叫做叫做rowSums 那么rowSums里面我们又再次用到了这个通配符 大家看到没有 我们用到select里面然后就是选择对吧 就实际上就是DPRY里面选择对吧 我们选择在这个 在这个DataFrame里面以Alex开头的所有的这些columns 然后呢再对这些所有的columns进行求和 以逐行求和 最后得到这个是真正的Alex的所有的这个Sum对吧 这是如果我们用这种方式来选的话 大家想想它实际上是Alex所有16个项目的一个求和 对吧我们前面这种方式的话它实际上只有4个 OK这是mutate 当然mutate我们还可以做其他的对吧 比方说我们重新编码 重新编码的话比方说我们这里 想要对这个根据出生年龄对吧 把它们分成不同的年龄段 而不是说年龄的这个数据本身对吧 那么这个时候我们就可以 直接对通过这个mutate里面 就是生成一个新的变量对吧 那么它怎么生成呢 我们用的另外一个叫做case1 case1就是说如果你符合条件 那么它会变成一个什么 如果你不符合条件会变成另外一个什么 它跟另外一个if else 就是在这个DPRY里面另外一个很像 那么if else它这个地方就是判断真假 那么它有三个argument 这个是真的这个是假的 那么这种方式其实 如果说我们要用到这个情况的话 那么我们要写很多个if else对吧 然后我们首先是看它是不是小于60年对吧 比方说是不是if else age 小于等于1960对吧 那么因为这个是true对吧 那么这个地方就意味着我们要填60对吧 就是如果age小于1960那就是60 那么这个地方如果它不是呢 如果不是的话我们又要加一个if else 然后又是age对吧 比方说小于 是小于的1979 然后and对吧 还加一个并的符号对吧 然后这个地方的话如果是true 我们就70对吧 如果它是否呢 你再来个if else 就是因为我们if else它只能做二分钟判断对吧 我们要做这种情况的话 我们就要写很多个if else 那么很容易犯错对吧 那么这个时候我们就开始做牛 假如它小于1969对吧 就是60 然后它再符合大于70对吧 然后小于79我们就当它70 那么最后一个true 然后这个n1号数属于这个函数里面 必须要加这个东西 要不然的话它会出错 也就是说有可能你的上面的条件没有 重进所有的情况 那么这个时候它应该给你怎么做 那么这样的话我们就能够什么 我们就能够对一个连续的数据对吧 对它进行重新编码 那么在心理学里面的话 我们有的时候很多时候 会比方说要对它进行反向编码 或者是怎么再进行一次 再次根据某个条件进行再次编码 我们都会遇到需要这种小的tricks 那么case 1的话或者叫if else的话 就是很好的这种帮助我们解决这些问题的函数 那么这个反向积分对吧 就是我们刚才说的这个case 1的 另外一种应用 如果说它原来等于1 那么我现在让它等于5 原来等于2 我让它现在等于4对吧 这也是case 1的一个很好的应用 反向积分的编码 然后拆分文件 拆分文件的话 比方说我们就 我们刚才比方说把它按照这个年龄出生的 这个讲说是哪个年代的 我们进行了一个分组 分组之后我们就直接可以让它进入group by 那么我们也就是说通过这个group by这个函数对吧 然后我们把它 第一个就是上面的这个输入的结果对吧 第一个argument 然后第二个的话就是我们按照什么进行分组 这个地方我们可以按照多个条件进行分组 不仅仅是按照一个 比方说我们要按照两个条件的话 我们就用c那个函数 比如说一个的话我们这里写的就是decades对吧 有c的话 或者两个的话比方说我们就是 就前面加一个小写的c小一点 然后比方说另外一个我们就说sex对吧 这样的话它就会按照这两个条件进行排列组合 把它们所有的独立的元素进行排列组合之后 然后进行重新分组 然后分完组了之后呢 我们就比方说可以去用summarize 这个函数去对每一个组的内部进行操作 比方说这里是一个非常常见的操作对吧 我们对某一个变量 就是某一个列进行求均值 这样的话我们 但我们一般可能不仅求均值 可能还求sd什么的 然后求完之后进行ungroup 把它重新拆分开来 方便我们做后续的运算 ok我把这个讲串到一起之后 我们就下个休息一下 那么我们把所有的学到的函数串到一起对吧 比方说我们第一步选择eat drink为1的base对吧 这个时候我们就是选择函我们用什么用filter 第二个我们选择我们所要的变量对吧 我们用select 然后对反向的题目进行重新编码 我们可以用mutate的case when加case when对吧 然后我们可以将出生年份编码为出生的年代的 比方说哪个60还70还是80对吧 然后我们最后求到 按照年代求annex的均值 用groupby加summarize然后加上ungroup 那么它最后就变成这样一个 我们可以以这个 大家看到我们输入是在这 dfpg.row对吧 就是我们这个pandredata的原始的数据对吧 第一行把它输入对吧 然后直接filter eat drink等于1的对吧 然后select 那么就是选择年龄 然后annex的数据 然后eat drink然后avoidance对吧 那么这样的话我们的数据量columns就大大减少对吧 然后我们对alex1进行反向编码 我们假定它是一个应该反向编码的一个 反向积分的一个题目对吧 反向积分完了之后 然后我们大家可以看看到上面是字符对吧,我们把字符全部转成数字,这个很 必要,要不然我没法进行运算,然后我们对这个row sum 就是说对这个annex求均值,这个时候我们用row sum 然后用select这个start with就是这个通配符的这种方法 简化了通配符的这个方法,然后同时大家可以看到我们在 rotate里面,我不仅仅是每次只做一个rotate,我们可以做多个 rotate,我们这个时候用decades也做这个rotate对吧 然后case when按照出生年代进行转换,转换之后 比方说这个地方我们就可以按照多个条件进行这个group by 对吧,但是我们只用了一个条件就是decades,所以说这个地方 就可以写的很简洁,就是一个decades就行了,然后我们用 summarize就mean annex,就是我们用annex总分的求一个均值 对吧,然后我们就ungroup,这就是我们假如说我们对 annex这个变量感兴趣对吧,那么我们从原始数据到最后 得到每个倍式,它在这个得分上的均值,然后就运算就完了 对吧,这就是我们基本上就是从原始数据到这个倍式的 数据的运算,那么我们接下来就可以对它进行画图或者是 做其他的运算对吧,假如说我们只对这个东西感兴趣的话 那我们就得到就是比方说60年代70年代他们的均值是这样的 好,OK,那我们休息一下 那个 这个是吧 这个是一个最后必须要加的一个东西 就是说最后必须要加 大家好,我们差不多开始了,那个 苏海耶同学要上来 回来 刚才这个大家觉得怎么样啊 很难吗 各位小组长,你们反馈一下 刚才讲回到这个 我后来我觉得主要就是大家不太熟悉啊 其实用多了就或者你接触多了就好了 他其实都没有想象那么复杂 对 所以我觉得这里面最重要的有几个,第一个就是说我们要看到 理解管道是如何操作的 因为这整个是把所有的 我们想对某一个变量的所有的域处理 基本上是把它拿回去拿 所以大家可以看到这里它会像一个 像一个管道一样有一个起点 然后有一个终点,然后最后 终点实际上是放在起点的前面的 把它作为一个输入 复到某一个变量里面 那么方便我们进行后续的操作 这里的每一个function,就是这个tklyr的 每一个function都可以单独拿出来使用 我们之前也 偶尔也试过,就是说 比如说groupby的话,我们其实可以单独拿出来 groupby,然后df对吧,或者某一个数据,然后逗号 就像它进行分组 分组完之后我们可以把这个分组的数据接到下一步去操作 但是放到管道里面的话,我们就可以把这个 表示从上一个上一步的操作的输出 作为这一步的输入,这一步就直接省掉了 尤其是当它作为第一个argument的时候 那么大家可以看到我们在tklyr里面其实基本上就可以看 处理某一个变量的所有的流程对吧 那么 还有另外一个,就是现在 Tidyverse里面有很多包,其实我们刚才已经接触到对吧,比方说 这里面有很多function,就这里面像有startwith 这个都是这里面的包,然后还有case1 还有这个rowsum 这都是一些单独的一些函数,并且绝大部分都是DPL 都是Tidyverse这个系统里面的 那么另外一个常用的就是tidyr 那么tidyr就是说让我们把这个数据变得更加的规整,它主要就是 把每个这个 就相当是把我们这个data frame做得更加的符合Tidyverse的风格 它这里有很多function也是非常常用的 那么这里常用的有这么几个,就是我们在社会科学或者心理学里面 常用的,比方说separator 将一个变量按照某个特定的规则 分成 分割成为几列 比方说我们这里举了一个例子,假如说你有一列变量全部是日期,那么日期的话都是有一个固定的格式,就是年月 对吧 然后日,然后中间都是一个短横线来分割的 那么有separator的话就可以把它分成三列 一列就是年,对吧,然后就是202,一列就是月,然后02 然后一列就是25 那么当然每一行可能是不一样的对吧,那么最后我们实际上就分成了 年、月、日的三个columns 然后extract的话就是说我们 我们不是把它分开,而是只是 把这个某一行的column里面特定的字符串提取出来 那么 我们可以提取一个也可以提取两个对吧 这个 unite就是把他们把separator,就相当于是一个反向的操作,我们上面是把分开对吧,下面就是我们把多个列 把它串成一行 串成一个列对吧 然后另外一个非常常用的就是这个pivot,就pivot longer和wider 那么我们刚开始以前的话,我经常用这个reshape,就是说 相当于是把数据进行重新的一个 重新的一个变换对吧,但现在发现TidyR里面这个pivot longer和wider 非常好用 并且它也在管道里面操作的非常好,就是我现在基本上就是用pivot longer和wider,就是说把我们的宽型数据转成长数据,长数据转成宽数据 那么长宽数据大家知道是什么吗 我问大家一个问题,就是比方说我们在SPSS里面的数据是长数据还是宽数据 一般来说 那么长数据一般就是我们 在这个软件里面记录的这种数据 大家见过eprime的那个 数据对吧 就是每一个 我想想啊 假如说我们有 一个就是很简单的几个变量啊 假如说我们分group对吧 就是 我们就说group,然后 比方说一个是 实验组对吧 一个是控制组 然后这个时候我们还有其他的变量,比方说有 base的ID对吧 然后有这个 变量对吧 然后比方说我们还有这个年龄对吧 那么长数据就是比方说 我们最后可能是这么一个形式 当然这个长度它是相对的,比方说这里有一个 ID 123456对吧 然后这个地方是比方说condition对吧 condition里面有 这个地方我们比方说是01,02对吧 是这样子 然后这个地方就是exp 然后control 假如是base内的 这个地方是01 然后这个是02 然后这个exp,然后这个control 然后这个地方 sex的话就是有他们的性别对吧 那么像这种情况的话,比方说我们单看这个 我们单看这一列对吧 单看condition这一列 那么每一个base都有两个条件对吧 那么我们实际上是在以行来对它进行重复对不对 就这个 这个是base1的数据,这个它也是base1的数据 对吧 这个地方我们是以 行来重复 这个condition的记录每一个值对吧 那么我们如果我们从看这个关注 关注这个condition的话,那么这就是一个常数据 为什么呢,就实际上是 每一个 就是我们用一列 把关于这个感性学变量所有的信息都记录下来了 然后它不仅仅有两个条件的话 它有五个条件的话,我们最后 这个 第一个base就应该有五行对吧 假如它有100个值的话,那就应该有100行对吧 那么快数据是什么呢 就是说我们同样的比方说有 有id 那么有sex和age对吧 那么这个时候我们可能就是直接就是exp 然后一个就是control对吧 那么这个时候 id就只有比方说01 02 03 每一个base它只有一个 它只有一行对吧 它只有一行值,然后它的这个我们关注的这个变量它实际上是 以这种 就是在column里面 并排这种方式对吧 这样的话它就是一个宽的数据,这个是一个长的数据 假如说我们想象是问卷的话那么 问卷比方说有 有五个item对吧,那就意味着我们这里就是有 你继续要写01对吧 那么就这个地方就是 这个是items的话 那么就是item i1 i2 i3 一直下去对吧 那这就是长数据 它就是在一个column里面 一直往下记录对吧 一行一行的记录每一个 这个变量的每一个取值,如果宽数据的话就是我们把它当作 columns 那么在这个地方的话它就是 i1,i2,i3,i4对吧 一直下去 那么每一个base的话它在这个地方 所以我们说的这个长转宽或者是宽转长就是 就是如何把这种长的转成这种宽的或者把这种宽的转成这种长的 那么这两种数据在这种两种形式啊,这两种数据的形式在我们R里面都会 都存在,并且有的时候 它可能会有特定的用途 我们后面会有例子啊 然后另外一个就是我们把这个NH的NH1和NH2的NH2的NH3的NH4的NH5的NH6的NH7的NH8的NH9的NH10的就dropNA,这个地方有的时候用,但是我也不经常用它,因为 大家想想dropNA可能跟我们前面讲那个filter对吧 其实有异曲同工之妙,但它这个drop的话就是 当你要把所有的NA都去掉的时候 你就用它,这是一个非常简单粗暴的办法 但是有的时候简单粗暴的办法,它可能会带来一些 有问题啊,就是要谨慎的使用 首先拆分啊,就比方说我们在这个 Match的这个数据里面对吧 在Match的数据里面我们有一个很重要的一行叫做Shape 就是我们这个形状它所代表的这个社会的意义对吧 那么它实际上是包含了两个质变量 一个是这个我们说Valence对吧,它代表的是 积极的中性的还是消极的,另外一个变量就是叫做Identity 就是说它是分 它是属于,应该是只有两个,Valence只有两个值,一个是好的一个坏的 那么Identity的话也只有两个,有两个值,一个是这个 自我还是他人 那么我们就可以用Separator去把它分开 那么所以我们这个地方的话用Separator就是说 上面的这个点代表的上面这个数据对吧,然后 Code等于Shape,就是说我们要对哪一个Column进行分割 然后分割,分割成什么东西对吧,我们分割成两个对吧 分割成两个Column,把一个Column分成两个Column 然后这两Column的Names分别是Valence和Identity 然后我们要按照什么规则进行分割 那么这里的话是一个比较 比较fancy的一个方式啊,就是 实际上就是我们还分成两部分 第一部分就是 要么是Moral,要么是Immoral 要么是Self,要么就是Other 那么这种方式呢,它不是唯一的 大家其实可以想一想还有没有其他的方式来进行分割 肯定是可以的 也就是说我们要做的就是把一个原来是比方说Moral,Self 对吧,分割成为一行是,一个Column是Moral 它的Column名字叫做Valence 然后另外一个Column叫做Identity 然后它对应的就是Self或者Other 那么我们现在要做的是一个制服分割的一个问题 那么这样的话我们就可能需要就是说 按照何种规则进行分割 那么这里显示的是一种规则 那么有的时候可能我们 这个制服本身它自带的这种 我们说自带的这种分割服对吧 就像我们前面那个日期里面讲到的 我们就是有个短的横线对吧 或者我们有下划线或者我们有点等等等等 如果你的这个制服里面内在就带有这种 带有这种分割制服的这种符号的话 你用这种符号分割是更好的 那假如说我们 就是对这一个Shape对吧 这个Column进行分割了以后呢 然后我们选择 选择的时候大家可以看到 这个选择可以帮助我们做一个事情 就是对Column进行重新排序 就是说我们选择的是 前面三个是Subject 然后Valence,然后Identity 然后Everything else 就是Everything,这又是一个 Function也是在Tidyverse里面非常常用的 当你比方说有几百行有几千行的时候 你想把前面的几个提出来对吧 你把关注的几个Columns提到前面来 你可以用Select这个函数 就把你感兴趣的放到前面几个 然后Everything else就是放到后面 这样的话你就是对Columns 进行了一个重新的排序 那么这样的话我们可以看到 我们如果分割正确的话呢 我们才能够后面进行这个选择 选择这个Column排序 我们可以看到就是Base 然后呢它这个Valence 然后它的Identity 就是出现了我们这个分割的效果对吧 然后以前的第一行对吧 Date然后还有这个什么它到底是 正式实验还是练习等等 全部到后面去了 这是我们的第一个讲解第一个功能 Separator 然后第二个就是Extract 其实内容差不多 但是呢这个时候 它实际上是用字符的这种 提取的方式就是用字符匹配的这种方式 我们去匹配按照这个叫做 正则式表达进行匹配 然后对它进行一个提取 把Shape 这个字段提取成为两个Columns 一个叫Valence一个叫Identity 然后我们根据这个正则表达去提取它 然后我们这个Extract这里Remove 等于Force就是说 我们提取出来之后把原来的Column 这个Shape并不删除掉 继续保留着 那么这样的话我们其实可以跟 刚刚得到一样的一个效果 那这个地方的话有一个可能后面以后 会让大家很头疼的一个一点 就是处理字符的时候 当我们的这个数据里面某个Column里面 包含字符的时候 我们想要去 按照特定的这个方式去匹配的时候 这点其实非常头疼的 就是我们要用那个正则式表达 那么大家可以去找一下 比方说叫做RegEx 就是叫做Regular Expression的一个缩写 就是你们可以找到这个 Tidyverse里面的RegEx 它的一个叫做Cheat Sheet 就是有一个表单 这个表单里面就是告诉大家 这个某一个符号代表的是什么意思 然后就是另外一个符号代表什么意思 这样的话你就能够去 在写这个RegEx的时候就更加方便 我也记不住这些东西了,因为太复杂了 我自己都是从来都是查表的 碰到问题的时候就去查表 我们现在看有没有网络可以搜索一下 比方说我们用 用Bin搜索一下 Tidyverse 这个大家经常说 所以说你搜多少都带看了 所以实际上是在 Tidyverse这个叫做StringR里面 它有一个专门的一个Cheat Sheet 就是一个 我们甚至都可以更加 我们可以更加直接一点 其实很多就是有很多这种表格 就直接你基本上能够看到 这个图对吧图表 你就能够找到这种很常见的这些 它是如何表达的 就现在大家可以自己后面去找 比方说像TidyData或是TidyR对吧 这里面就是有这种很多的 这个如何去操纵的一些内容 当然因为我们是关于我们是关于 这个StringR的 我们有可能要找这个StringR的一些相关的一些 Cheat Sheet 这样的话你就不用去记了 我也并不鼓励大家去记这些东西 没有什么意义 那么比方说我们可以把刚才的这个 分开的两列对吧 我们可以把它重新组合起来 我们就是用这个Unite这个函数 也是TidyR里面这个函数 我们把比方说 这两行对吧 就前面的表示你把它 联合起来之后你要把它命名叫什么 然后后面两个就是表示你对哪几个进行一个命名 有的时候你可以比方说 你可能要对多个进行的时候 你还可以用冒号来 表示从哪一个到哪一个进行选择 然后这个Sep就表示你用什么来分割 你来自不同Columns的这些字符串 那么比方说像我们的话就是 两个冒号中间是空格 就代表什么都没有 其实就是把它完全的连到一起 然后这个是宽转长 就是PivotLonger 大家想想宽转长的话 就是相当于是我们要把 其实有一些比较好的可视化 我再根据我们的情况稍微 但是我们现在要转的是什么 是把RT和ACC对吧 转成一个叫DV的一个东西 那么实际上假如说我们原来是这样对吧 假如说我们有subject 你那么它有一个行叫RT有一个叫ACC对吧 那么它这里有两个值 那么我们现在就是把它转成一个 subject01 然后我们叫DV的一个Column对吧 然后这里就是一个Column 然后我们还有一个就是有个value 这里还有一个value就是我们这里比方就是有RT 然后它对应的值ACC对应的值 然后相当于是我们把这里面比方说有一个 我们是800对吧 然后ACC这里是1对吧 那么转了之后的话实际上就是把这个转到了这个 然后把这个转到了这个 我们看一下这个PivotLonger 第一个就是我们对哪一些Column把它要 它是宽的对吧 就是说以前它是Columns 然后我们要把它转成长的 转长的时候有一个就是我们要对 原来的Column我们要对它进行index对吧 我们不能把信息完全消失掉 我们转换的话就它不是一个等价的 它的信息就损失了对吧 也就是说原来的ColumnNames 然后这里RT和ACC对吧 它在新的长的这个DataFrame里面 它必须要有一个新的Column来去 表示它原来是属于哪一个Column对吧 我们原来这个地方是ColumnNames是RT对吧 那么现在RT变成了这个叫做DV的Column的一个取值 同样ACC的话它原来是一个ColumnName 我们现在把它变成了这个里面 也是叫做DV里面的一个取值对吧 我们相当于说我们把原来的ColumnNames的信息保存下来 那么它的值呢我们也把它保存下来 这个值就是在一个叫value的一个Column里面保存的对吧 所以我们就把原来这个 长的这个宽的这个数据 完全没有任何损失的转成了一个长的数据 它只不过是把信息保存的这个方式发生了一点变化 以前是用Column来表示的 那么现在我是用一个Column 表示它的取值是什么 另外一个Column表示它对应的值是什么 这个地方大家懂了吗 理论上懂了吗 理论上懂了吗 理论上懂了就可以 因为我们待会马上就要操作了 这个不操作的话可能没有直观的印象 我们再看一下就是这里面 PivotLonger最重要就是说你要对哪些 你要把哪些Columns合并起来成为一个 就是变成长的 然后你要合并了之后对吧 这些ColumnNames它会记录在哪一个新的Column里面 然后原来的每个Column下面的这个value 这些数值它记录在哪一个Column里面 所以大家看到这个argument 这个参数都是非常的直接的 就是NamesTo对吧 你原来ColumnsNames变成了哪一列变量 你原来的values变成了哪一列Column 哪一列变量 然后这个PivotWider就是我们把它变得 从长转宽对吧 那么我们假定是用刚才那个长 就是宽的数据对吧 已经转成宽的数据我们把它还原 就做一个逆向的操纵 那么做一个逆向操纵的话 有一个很重要的点就是我们需要知道它的 这个它的index是独特的 那么我们这里为了简化 我们在这里为了简化 我们实际上是做了一个就是把这里面的 就是RT和ACC先求了一个均值 先把它分组之后 比方说大家可以看到我们先选出一些变量对吧 就是subject然后trial然后shape dv dv就是我们刚刚剩的那个长的变量的 就是原来的这个ColumnNames把它变成dv的对吧 然后values就是原来的数值变到了value这个Columns里面 然后我们通过这个groupBy groupBy了以后然后就对它进行了一个求值 求均值 好我们对这个均值进行一个转换,然后names from就是说 我们要从哪一个,我们要从哪一个这个 哪些columns里面对吧,去得到新的这个宽的数据的这个column names 我们这里有两个column,一个是shape,一个是dv,就是 我们前面用来计算这个均值的对吧,就是这个图形的 这个valence,不是图形的条件,然后dv就是rt和acc对吧 然后values from,values from就是说我们变成宽的之后 就是有多个columns对吧,那么多columns names from就是说我们刚刚得到的是它的 它的这个columns的名字对吧 另外一个就是values from,就是说你原来的这个 你变得这么多宽的这么多columns之后 你每一个column的数值从哪来对吧,就是这里的这个mean value 然后这个names glue就是说你把原来的这个 原来的这,你这里不是有两个column对吧 你的新的这个,就是展开了的这个变宽了的这个 有很多columns对吧,这column名字 你是从,你是原来是从两个column里面变过来对吧 你要怎么把原来两个column 把它组合之后,得到新的column的名字 这个时候我们是用了这个,就是实际上就是用了一个 下滑线对吧,把它进行组合 当然我们也可以采用其他方式进行组合 比方说我们可以把dv放前面对吧,把same放后面 这样的话我们可能就是rt然后下滑线,然后点immoral order 那么这个时候的话,我们就得到的就是这样的一个数据对吧 就是每一个倍式它就只有一行 大家看到,它只有一行,然后它会 在不同条件下的均值对吧,比方说这个acc的话 它就变成了一个平均的正确率 然后rt的话,它就变成了这个多少秒对吧,0.57 然后每个条件都会有这样的一个数值 那这就是我们演示了一下这个长宽之间的转换 这个实际上是一个非常常见的 我觉得大家如果用R处理数据的话,这个是非常常见的一个操作 然后把这个最后一个很简单的就是 把缺失值的都去掉吧,就是假如说你最后 你想把任何一个column里面包含的缺失值 你就把它全部去掉的话,就相当于是你最后得到的数据 是要全部每一个column都有 都是没有缺失的这种数据,那你可以用dropna 那么dropna之后的话你可以 就是我们通过这个paste就是 这个实际上就是打印出来我们这个结果 就是比方说原来的数据集是有这么多行对吧 然后你缺失之后,你把这个nrow就是它打出来就有这么多 你可以看到这个区别 就是我们通过dropna去掉了哪些 这里你可以用paste,你也可以用其他的比方说print也可以打印出来 主要的一个目的是什么呢,就是帮助大家看一下 你通过这个操作你去掉了多少行 有的时候你自己需要去double check 就是说你做了某一个操作之后没有报错对吧 你要看一下这个结果是不是符合你的需要的 OK,那我们把刚才的这些东西再结合到一起 选择我们要的变量,然后删除缺失值 然后选出我们符合标准的这个倍数对吧 然后计算平均的反应时和正确率 然后进行拆分,然后再进行这个数据的长宽的转换 然后可以计算比方说我们要得到某一个音变量 efficiency对吧,我们可以通过mutate来计算 那么选择的变量对吧,这个就是很简单的select 然后select完了之后,其实我们就 比方说我们这里是用这个DFMT clean对吧 得到复制成为一个结果 然后我们以这个原来的clean作为结果 都是输入对吧,然后我们重新进行一番操作 然后得到一个新的变量,仍然叫做clean对吧 实际上就是把这个变量进行一个更新 这个地方我们是选择的是右利手的贝式 然后排除了这个无效的应答对吧 然后选择了一个合理的反应时间 这是我们排除贝式的标准 在Rting里面我们可能 大家如果做反应时的这个实验的话 可能也会通过反应时间进行一些试测的筛选对吧 然后分实验条件计算它的一个均值 比方说我们需要计算每个贝式 在每个实验条件下它的均值是什么对吧 那么我们这个时候就可以通过这个 比方说假如说我们这里有sub sub就是每个贝式的 然后shape就是每个条件 然后match的话也是另外一个条件 那么我们计算它们的这个平均的正确率 然后平均的反应时间,然后ungroup 那么这个时候我们可以用mutate这个值 我们就生成了一个新的变量 比方说我们就对 假如说efficiency它是一个大家认可的一个值 就是用反应时间除以它的一个正确率 当然这可能是一个在某些文章中才会用到的 我们这里只是做一个展示 那么这样的话我们就新生成了一个efficiency这个变量 它实际上就是我们用minRT和minACC得到的 那么我们可以对变量明星拆分 后面画图的时候更方便一点 比方说我们用shape进行拆分 那么我们也可以再进行一个选择 就是我们选择这个match的条件下的数据 然后选择这个valence对于moral的条件 那么最后就得到了这么一个我们想要的一个结果 那么我们再对它进行长宽的转换 我们可能可以把它转成自我和他人条件下的一个数据 那么就是我们刚才的这个 选择这个base然后identity然后efficiency 因为其他的变量都已经处理掉了 然后把它变成宽的数据 names from就是identity values from就是efficiency 所以最后得到就是每一个base在每一种条件下 在match条件下自我和他人的efficiency 那么我们计算这个SPE的话 就是我们计算比方说叫做自我参照 自我优先加工效应 就是我们想要知道自我和他人相比 在加工上面有没有差异 那么我们就用为什么我们要转宽呢 实际上就是为了下一步的计算 就是为了计算我们感兴趣的一个效应量 大家都已经跟不上了 然后放到一起就是这样了 这个看起来就会稍微复杂一点 好我们现在来一个提问时间 大家哪一个地方不太懂 要不这样吧 就是我们接下来 我们本来是有一个练习 就是计算大家的信号检测论的 这个D' 但是我们可能 大家先练习一下前面的吧 我们不是每个人都有这个RMAP站吗 对吧 大家可以 今天可能太猛了 要不大家就是 DPL YR这里 就是我们现在第28张PPT显示这里 大家能不能再自己练一下 把这个跑出来 能不能运行出来 然后能不能运用出来是第一步 然后大家看有什么问题 然后如果这个没有问题呢 我们就自己在自己的电脑上面运行下一个 我们刚刚说连起来这个 就是第47页的这个 然后我们先还是把PPT放到第28页 这个地方 那么大家先看自己能不能在电脑上重现这个 如果这个不能重现的话 我觉得确实就理解下来就比较困难了 然后各个小组长 大家可以协调一下看 我在想就是说每个人在自己的电脑上面 把这个代码 就是你run一下 保证你能够得到 就是说跟我们一样的结果 然后你自己再看一下这里面 每一行是什么 会得到什么结果 然后怎么运行呢 我建议就是说你不用一行一行的写 就是说你首先把这个数据读取进来 对吧 这个raw data读取进来 读取进来之后呢 你可以 因为我们的代码全部是发给大家的 大家可以把这个完整的copy到自己的 写代码的地方去 写脚本的那个文件 然后你就选择 比方说你选第一行 前面两行对吧 选到这个之前 就你不要把这个管道符号选进来 比方说你就选到这个地方 然后呢 你就运行一下 这样的话 它实际上就表示我们只运行这个管道的 前面两步 对吧 或者你可以在任何一个地方 你只要把这个选择的代码是在 管道符号之前 你就可以在 整个管道里面 其实可以 就是任意的去 就是选择前面一半的进行运行 假如说你觉得我 OK我不想 我只想就是比方说我 跳到下一个地方 看能不能运行 那么你可以把中间的注释掉 怎么注释掉呢 你在这个前面加上一个警号 那么这一行代码就注释掉了 那么在注释的时候呢 就是把这行代码注释掉的时候呢 最好就是 你要看到这个括号的关系 就是比方说你 你注释了这一行的话 对吧 你下面的这几行其实都无效了 所以你要把下面几行都注释掉 明白我的意思吗 我这里想说的就是 因为这个代码很长啊 所以大家可能 一下运行完了之后呢 没有任何出错 对吧 但是什么东西都没学到 你怎么知道自己在干什么呢 你就运行一部分的代码 明白吗 运行一部分的代码 怎么运行一部分的代码 选择一部分的代码 然后control加回车 选择一部分的代码 就比方说你选择前面的 两行或三行 比方说我现在就是选择前面三行 这个时候运行的话 我们只会做前面的两个操作 它就会把它复制到这个 df.pg.clean里面去 你这个时候可以点开这个 df.pg.clean 因为我们都在RMAP档里面对吧 你可以看看它到底发生了什么变化 这样的话你才能够知道 每一行做了什么东西 然后另外一个就是我们在 在写R代码的时候 我们有个很重要的功能 我们好像之前没有介绍完 就是在这个R代码里面 我们不是直接开始写吗 对吧 在那个脚本里面 比方说这是一个txt对吧 比方说是一个什么.r的一个txt 我们就直接在那边写代码 比如说这是ray的csv是吧 假如我们在前面加个警号的话 就表示把这个代码变成了文字 这样的话你可以运行的时候 你就不会再运行它了 这个我们称之为把这个代码注释掉 在英文里面叫commented 就是我们将这个东西变成一个comment 而不是代码 这是我们检查代码的时候 很常规的一个操作 比方说我现在有两个做法对吧 一个a一个b我不知道哪个是对的 我先测试a 然后我把 因为写b的时候它跟a很像 我把bcopy一下 然后在下面 但是我又不想把a删掉 那么我就在a前面加一个comment 加个警号 那么这样的话 它就不会再管这个a了 那么我就直接去运行b对吧 我们发现b不行 我们又回来改a的时候 我们把b再加个警号 那么b也无效了 这是一个常用的一个小的技能 我好像之前没有讲 首先大家要记住 第一个小目标就是把这个完整的运行 那么要完整运行的话 你首先必须把这个数据读进来对吧 然后第二个小目标就是你去 逐行逐行的去运行这里面的每一个mini 然后有什么问题或者不理解的 然后随时举手 确实讲的有点快啊感觉 大家玩意儿听懵了 主要是今天设计的函数比较多不难,就主要大家不熟悉,真的。 我刚刚说的,要是没听懂的话。 大家刚刚碰到一个小问题啊,就是比方说我们这里的一个数据,对吧? 叫DFPG.raw,从哪来的,对吧? 那实际上是我们前面读取的。 我们前面读取的,我们之前是用Panguin,对吧? DFPanguin。 我们今天换了一个比较简短的名字。 大家不要因为这个就不认识了,我们可以回到前面一点。 我们这里有个读取原始数据,大家还记得吧? 可能当时过得很快,大家一下就忽略了。 我们在这里把原始数据,就是前面把多个out文件合并之后, 这个原始数据保存了,然后在这里读取了一遍,对吧? 就成了这个df.mt.raw。 然后我们也有这个tanguindata,对吧? 我们把它读成了df.pg.raw。 我再回到刚才那个。 大家好,我们今天就差不多到这儿。 如果大家还要继续讨论的话,我们也可以在这待一会儿。 然后各小组的要知道,就是像今天留了一个课外作业, 然后这个课外作业就是大家要知道的任务是什么? 是对所有的match的这个数据,就是我们这节课一开始, 通过Holo或者是通过Lplot读的那个数据, 把那个数据读起来以后合并起来, 然后成为了一个完整的数据,对吧? 就是一整个实验的完整数据。 应该说是一个完整的实验的其中一个任务的数据。 那么对这个任务的数据,求它的那个就是d' 信号检测论的d'. 那么这个地方我们实际上是已经有代码了, 就是用Lplot来去读这个所有的包含match的这些数据的文件, 然后并且把它组合成为一个单纯的数据集,就是这个东西。 然后我们也有代码把它写成一个csv, 这是我们其实一开始上课的时候讲过的内容。 所以大家操作的课外作业操作的内容就是这个东西, 就是这个,你可以认为是这个, 就是我们这节课特指的这个数据集。 然后,那么信号检测论, 我相信大家考研的时候都考过,心理学的同学。 信号检测论的话,就是说我们要以match作为信号, 以mismatch作为噪音, 因为大家知道信号的话是有一个信号和噪音的对吧? 所以这个情况下什么是击中率对吧? 击中率的话就是你条件为match, 然后你确实答对的,这个就是击中对吧? 然后如果你的条件是mismatch, 然后你的正确率是0, 就表示你把它按键按成了match对吧? 这个情况叫做false positive,就是虚报。 然后miss就是说你的这个match条件它是match, 但是你答错了,你把它按成了mismatch对吧? 这就是你错失了。 还有一个叫做correct rejection对吧? 就是你的条件就是mismatch,就是噪音, 然后你按键也是噪音。 然后我们通过信号检测的计算方法, 然后进行后面的一系列的计算, 这里其实我们基本上已经给出了模板, 但是希望大家把完整的整个workflow写出来。 就是要写出一个类似这个东西来, 从原始数据出发, 然后做后面的一系列的筛选, 最后得到每个倍式有一个d'。 每个倍式的每个条件有一个d'。 因为大家看到我们这里有两个条件, 有一个valence,有一个identity, 所以最后一个你想做的话, 大家给一个什么结果呢? 就是说大家这个作业完了之后, 你可以给一个很简洁的一个结果, 就是比方说第一个就是subject id对吧? 然后第二个你就是比方说valence, 就是他们这个valence这个条件, 然后第三个就是id对吧? 然后第四个就是d'。 我们希望得到的就是这么一个东西, 你可以非常简洁, 就是只有这么多, 只有四个columns, 然后每一个倍式就是有它自己有一行, 就是这么一个宽型的一个数据。 OK,小组长如果你们有问题的话, 你们可以随时来问一下。 我们小组长单独有一个群啊, 就是为了方便大家对这种交作业啊, 或者什么问题不太方便的时候来进行讨论。 小组长,跟我们那个刘萌萌说个介绍, 我们下一周可能让大家说一下自己的思路啊。 点一下铭说一下自己的思路。